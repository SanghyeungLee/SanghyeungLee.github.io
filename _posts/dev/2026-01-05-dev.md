---
layout: post
title: "Saga 오케스트레이션: DB 트랜잭션과 API 연동의 조화"
category: dev
---

오늘 **Saga 오케스트레이션**에 대해 공부하면서 분산 시스템에서 트랜잭션을 어떻게 관리해야 하는지 깊이 생각해볼 수 있었다.

## 문제 상황

여러 API가 순차적으로 실행되는 마이크로서비스 아키텍처에서, 중간에 위치한 API를 개발하고 있었다. 이 API는:

1. **DB 트랜잭션**을 사용해 데이터를 저장해야 했고
2. 동시에 **다른 API와 연동**해야 하는 상황이었다
3. 여러 API가 순차적으로 흘러가는 파이프라인 중간에 위치해 있어서, 전후 컨텍스트를 잘 관리해야 했다

## 깨달은 점

### 1. 트랜잭션의 범위와 보상(Compensation) 로직

DB 트랜잭션과 API 연동 트랜잭션을 동시에 사용할 때, 오류가 발생하면 **모든 작업을 원래 상태로 되돌려야** 한다는 점이 중요했다.

**Kotlin + Ktor**로 구현할 때는 코루틴과 함께 다음과 같이 처리했다:

```kotlin
suspend fun processWithTransaction(data: RequestData): Result {
    var externalApiCalled = false
    var externalApiResult: ExternalApiResponse? = null
    
    return transaction {
        try {
            // 1. DB 작업
            val dbRecord = db.insert(data)
            
            // 2. 외부 API 호출 (트랜잭션 밖에서 실행)
            // 주의: DB 트랜잭션 내에서 외부 API를 호출하면 안 됨!
            externalApiResult = httpClient.post("/external-api") {
                contentType(ContentType.Application.Json)
                setBody(data)
            }.body<ExternalApiResponse>()
            externalApiCalled = true
            
            // 3. API 결과를 DB에 반영
            db.update(dbRecord.id, externalApiResult)
            
            Result.Success(externalApiResult)
        } catch (e: Exception) {
            // 롤백: DB 트랜잭션은 자동으로 롤백됨
            
            // 보상: 이미 호출한 외부 API에 대한 보상 작업
            if (externalApiCalled && externalApiResult != null) {
                try {
                    httpClient.post("/external-api/compensate") {
                        contentType(ContentType.Application.Json)
                        setBody(CompensateRequest(externalApiResult!!.id))
                    }
                } catch (compensateError: Exception) {
                    // 보상 실패 로깅
                    logger.error("Compensation failed", compensateError)
                }
            }
            
            Result.Failure(e)
        }
    }
}
```

Ktor의 코루틴 기반 비동기 처리와 Exposed의 트랜잭션을 함께 사용하면서, 외부 API 호출의 타이밍과 보상 로직을 신중하게 설계해야 했다.

### 2. 순차적 파이프라인에서의 위치 인식

여러 API가 순차적으로 실행되는 환경에서, 내 API가 중간에 위치한다는 것은:

- **이전 API의 결과**를 받아서 처리해야 하고
- **다음 API가 기대하는 형식**으로 데이터를 전달해야 한다
- 중간에 실패하면 **이전 단계들도 모두 롤백**해야 할 수 있다

이를 위해서는:
- 명확한 **인터페이스 규칙** 정의
- **상태 관리**와 **에러 전파** 메커니즘
- **보상 트랜잭션(Compensating Transaction)** 설계

가 필수적이라는 것을 깨달았다.

### 3. Saga 패턴의 필요성

전통적인 2PC(Two-Phase Commit)는 분산 환경에서 성능과 가용성 문제가 있다. 대신 **Saga 패턴**을 사용하면:

- 각 서비스가 로컬 트랜잭션을 관리
- 실패 시 보상 트랜잭션으로 롤백
- 순차적 또는 병렬 실행 가능

이를 통해 더 유연하고 확장 가능한 분산 트랜잭션을 구현할 수 있다.

## 다음 단계

- **Kotlin/Ktor 환경에서의 Saga 패턴** 구현 방법 더 깊이 연구
- Temporal이나 AWS Step Functions 같은 오케스트레이션 도구와 Ktor 통합 방법 조사
- 보상 트랜잭션 설계 패턴을 실제 프로젝트에 적용해보기
- 코루틴 기반 분산 트랜잭션 처리 패턴 정리
